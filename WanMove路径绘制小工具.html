<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ— é™ç”»å¸ƒè·¯å¾„ç¼–è¾‘å™¨</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #1e1e1e; color: #ddd; font-family: "Segoe UI", sans-serif; user-select: none; }
        #app { display: flex; height: 100vh; }
        
        /* Sidebar */
        #sidebar { width: 300px; background: #252526; padding: 15px; border-right: 1px solid #3e3e42; display: flex; flex-direction: column; gap: 12px; z-index: 10; box-shadow: 2px 0 5px rgba(0,0,0,0.3); }
        h2 { margin: 0 0 5px 0; font-size: 16px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 8px; }
        .control-group { background: #2d2d30; padding: 10px; border-radius: 4px; }
        label { display: block; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        input[type="number"], input[type="text"] { width: 100%; background: #3c3c3c; border: 1px solid #555; color: #fff; padding: 4px; border-radius: 3px; box-sizing: border-box;}
        input[type="range"] { width: 100%; cursor: pointer; }
        
        /* Buttons */
        .btn-row { display: flex; gap: 5px; margin-bottom: 5px; }
        button { flex: 1; background: #3a3a3a; color: white; border: 1px solid #555; padding: 6px; cursor: pointer; border-radius: 3px; font-size: 12px; transition: all 0.2s;}
        button:hover { background: #4a4a4a; border-color: #777; }
        
        button.primary { background: #0e639c; border-color: #1177bb; }
        button.primary:hover { background: #1177bb; }
        button.danger { background: #8a1b1b; border-color: #a32a2a; }
        button.danger:hover { background: #b32424; }
        
        /* Toggle Button Active State */
        button.active { background: #c58620; border-color: #e09f3e; color: #1e1e1e; font-weight: bold; }
        button.active:hover { background: #dba032; }

        button:active { transform: translateY(1px); }

        textarea { width: 100%; height: 120px; background: #1e1e1e; border: 1px solid #3e3e42; color: #00ff00; font-family: monospace; font-size: 11px; resize: vertical; padding: 5px; box-sizing: border-box;}
        
        /* Canvas */
        #canvas-container { flex-grow: 1; position: relative; overflow: hidden; background-color: #121212; 
            background-image: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px; }
        canvas { display: block; outline: none; }
        
        .info { font-size: 11px; color: #888; margin-top: 5px; line-height: 1.4; }
        .highlight { color: #4ec9b0; font-weight: bold; }
        .shortcut { display: inline-block; background: #444; padding: 0 4px; border-radius: 3px; color: #fff; margin-left: 5px; font-family: monospace;}
    </style>
</head>
<body>

<div id="app">
    <div id="sidebar">
        <h2>è·¯å¾„ç¼–è¾‘å™¨</h2>
        
        <div class="control-group">
            <label>1. ç”»å¸ƒè®¾ç½®</label>
            <input type="file" id="imgUpload" accept="image/*">
            <div class="info" style="margin-top:5px">
                ğŸ–±ï¸ <strong>ä¸­é”®æ‹–æ‹½</strong>ï¼šå¹³ç§»ç”»å¸ƒ<br>
                ğŸ–±ï¸ <strong>æ»šè½®</strong>ï¼šç¼©æ”¾è§†å›¾<br>
                âŒ¨ï¸ <strong>Ctrl+Z</strong>ï¼šæ’¤é”€æ“ä½œ
            </div>
        </div>

        <div class="control-group">
            <label>2. è·¯å¾„æ“ä½œ</label>
            <button id="btn-draw" onclick="editor.toggleMode('draw')" style="width:100%; margin-bottom:5px">âœï¸ è¿›å…¥ç”»ç¬”æ¨¡å¼ (æ‹–æ‹½ç»˜åˆ¶)</button>

            <div class="btn-row">
                <button class="primary" onclick="editor.addCurve()">+ æ–°å»ºæ›²çº¿</button>
                <button onclick="editor.reverseCurve()">â‡… åå‘è·¯å¾„</button>
            </div>
            <div class="btn-row">
                <button class="danger" onclick="editor.deleteSelectedCurve()">ğŸ—‘ï¸ åˆ é™¤é€‰ä¸­æ›²çº¿</button>
            </div>
            <button class="danger" style="width:100%; margin-top:5px; opacity: 0.8" onclick="editor.clearAll()">âš ï¸ æ¸…ç©ºæ‰€æœ‰</button>
            
            <div class="info" style="margin-top:8px">
                â€¢ <strong>å·¦é”®å•å‡»</strong>ï¼šé€‰ä¸­æ›²çº¿ / é€‰ä¸­ç‚¹<br>
                â€¢ <strong>å·¦é”®æ‹–æ‹½</strong>ï¼šç§»åŠ¨ç‚¹ (ç¼–è¾‘æ¨¡å¼)<br>
                â€¢ <strong>åŒå‡»æ›²çº¿</strong>ï¼šæ’å…¥ç‚¹<br>
                â€¢ <strong>å³é”®ç‚¹å‡»ç‚¹</strong>ï¼šåˆ é™¤ç‚¹
            </div>
        </div>

        <div class="control-group">
            <label>3. å¯¼å‡ºå‚æ•° (å…³é”®)</label>
            <label>å¹³æ»‘åº¦ (Tension): <span id="tensionVal">0.5</span></label>
            <input type="range" id="tension" min="0" max="1" step="0.05" value="0.5">
            
            <hr style="border:0; border-top:1px solid #444; margin: 10px 0;">
            
            <label class="highlight">ğŸï¸ è¾“å‡ºæ€»å¸§æ•° (Total Frames)</label>
            <div style="display:flex; gap:5px;">
                <input type="number" id="totalFramesInput" value="81" min="2" step="1" style="flex:1">
            </div>
            <div class="info">
                æ‰€æœ‰è·¯å¾„å°†å¼ºåˆ¶æŒ‰ç…§æ­¤æ•°å€¼ç”Ÿæˆç‚¹æ•°ï¼Œç¡®ä¿ ComfyUI ä¸æŠ¥é”™ã€‚
            </div>
        </div>

        <div class="control-group">
            <label>4. æ•°æ®å¯¼å‡º</label>
            <textarea id="output" readonly placeholder="JSON æ•°æ®åŒºåŸŸ"></textarea>
            <div class="btn-row">
                <button class="primary" onclick="editor.exportJson()">ç”Ÿæˆå¹¶å¤åˆ¶</button>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" tabindex="0"></canvas>
    </div>
</div>

<script>
/** å‘é‡å·¥å…·åº“ */
const Vec2 = {
    add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
    sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
    dist: (a, b) => Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2),
    angle: (a, b) => Math.atan2(b.y - a.y, b.x - a.x)
};

class SplineEditor {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('canvas-container');
        
        // æ•°æ®çŠ¶æ€
        this.curves = []; 
        this.currentCurveIndex = -1;
        this.bgImage = null;
        
        // å†å²è®°å½• (Undo)
        this.history = [];
        this.maxHistory = 50; // æœ€å¤§æ’¤é”€æ­¥æ•°
        
        // æ¨¡å¼: 'edit' (é»˜è®¤) æˆ– 'draw' (ç”»ç¬”)
        this.mode = 'edit'; 
        this.isDrawing = false; // ä»…åœ¨ draw æ¨¡å¼ä¸‹ä½¿ç”¨

        // è§†å›¾çŠ¶æ€ (æ‘„åƒæœº)
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        
        // äº¤äº’çŠ¶æ€
        this.isDraggingPoint = false;
        this.isPanning = false;
        this.dragTarget = null; // { curveIndex, pointIndex }
        this.lastMouse = { x: 0, y: 0 };
        
        this.init();
    }

    init() {
        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.addCurve();
        this.offsetX = this.canvas.width / 2;
        this.offsetY = this.canvas.height / 2;

        // äº‹ä»¶ç»‘å®š
        this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
        window.addEventListener('mousemove', e => this.onMouseMove(e));
        window.addEventListener('mouseup', e => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
        this.canvas.addEventListener('dblclick', e => this.onDblClick(e));
        this.canvas.addEventListener('contextmenu', e => this.onContextMenu(e));
        
        // é”®ç›˜äº‹ä»¶ (Ctrl+Z)
        window.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                this.undo();
            }
            // ä¹Ÿå¯ä»¥å¢åŠ  Delete é”®åˆ é™¤é€‰ä¸­æ›²çº¿
            if (e.key === 'Delete') {
                this.deleteSelectedCurve();
            }
        });

        // UIç»‘å®š
        document.getElementById('imgUpload').addEventListener('change', e => this.handleImage(e));
        document.getElementById('tension').addEventListener('input', (e) => {
            document.getElementById('tensionVal').innerText = e.target.value;
            this.draw();
        });
        
        document.getElementById('totalFramesInput').addEventListener('change', () => {
           // è¿™é‡Œä¸éœ€è¦é‡ç»˜
        });

        this.draw();
    }

    resize() {
        this.canvas.width = this.container.clientWidth;
        this.canvas.height = this.container.clientHeight;
        this.draw();
    }

    // --- å†å²è®°å½• (Undo) ---
    saveState() {
        if (this.history.length >= this.maxHistory) {
            this.history.shift(); // ç§»é™¤æœ€æ—©çš„è®°å½•
        }
        // æ·±æ‹·è´å½“å‰çš„æ›²çº¿æ•°æ®å’Œé€‰ä¸­çŠ¶æ€
        const state = JSON.stringify({
            curves: this.curves,
            currentCurveIndex: this.currentCurveIndex
        });
        this.history.push(state);
    }

    undo() {
        if (this.history.length === 0) return;
        
        const lastState = JSON.parse(this.history.pop());
        this.curves = lastState.curves;
        this.currentCurveIndex = lastState.currentCurveIndex;
        this.draw();
    }

    // --- æ¨¡å¼åˆ‡æ¢ ---
    toggleMode(targetMode) {
        if (this.mode === targetMode) {
            this.mode = 'edit'; // Toggle off
        } else {
            this.mode = targetMode;
        }
        
        // æ›´æ–° UI
        const btn = document.getElementById('btn-draw');
        if (this.mode === 'draw') {
            btn.classList.add('active');
            btn.innerHTML = "âœï¸ é€€å‡ºç”»ç¬”æ¨¡å¼";
            this.canvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            btn.innerHTML = "âœï¸ è¿›å…¥ç”»ç¬”æ¨¡å¼ (æ‹–æ‹½ç»˜åˆ¶)";
            this.canvas.style.cursor = 'default';
        }
        this.draw();
    }

    // --- åæ ‡è½¬æ¢ ---
    toWorld(sx, sy) {
        return { x: (sx - this.offsetX) / this.scale, y: (sy - this.offsetY) / this.scale };
    }
    toScreen(wx, wy) {
        return { x: wx * this.scale + this.offsetX, y: wy * this.scale + this.offsetY };
    }

    // --- äº¤äº’äº‹ä»¶ ---

    onMouseDown(e) {
        this.canvas.focus();
        const mouse = { x: e.offsetX, y: e.offsetY };
        const worldMouse = this.toWorld(mouse.x, mouse.y);

        // ä¸­é”® (Button 1) -> å¹³ç§» (ä¼˜å…ˆçº§æœ€é«˜)
        if (e.button === 1) {
            this.isPanning = true;
            this.lastMouse = mouse;
            this.canvas.style.cursor = 'grabbing';
            e.preventDefault();
            return;
        }

        // å·¦é”® (Button 0)
        if (e.button === 0) {
            // === ç”»ç¬”æ¨¡å¼é€»è¾‘ ===
            if (this.mode === 'draw') {
                this.saveState(); // æ“ä½œå‰ä¿å­˜çŠ¶æ€
                this.isDrawing = true;
                this.addCurve(false); // false = ä¸è®°å½•å†å²ï¼Œå› ä¸ºä¸Šé¢å·²ç»è®°å½•äº†
                this.curves[this.currentCurveIndex].points.push(worldMouse);
                this.draw();
                return;
            }

            // === ç¼–è¾‘æ¨¡å¼é€»è¾‘ ===
            // 1. æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†æ§åˆ¶ç‚¹
            const hitPoint = this.hitTestPoint(worldMouse);
            if (hitPoint) {
                this.saveState(); // å‡†å¤‡æ‹–æ‹½å‰ä¿å­˜çŠ¶æ€
                this.isDraggingPoint = true;
                this.dragTarget = hitPoint;
                this.currentCurveIndex = hitPoint.curveIndex; // é€‰ä¸­è¯¥æ›²çº¿
                this.draw();
                return;
            }

            // 2. æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†æ›²çº¿ (ç”¨äºé€‰æ‹©)
            const hitCurveIdx = this.hitTestCurve(worldMouse);
            if (hitCurveIdx !== -1) {
                // ä»…é€‰æ‹©ä¸éœ€è¦æ’¤é”€ï¼Œä½†å¦‚æœä¹‹åæ“ä½œéœ€è¦çŠ¶æ€å¯¹é½ï¼Œä¸ä¿å­˜ä¹Ÿå¯
                this.currentCurveIndex = hitCurveIdx;
                this.draw();
                return;
            }

            // 3. ç‚¹å‡»ç©ºç™½å¤„
            // å¦‚æœé€‰ä¸­äº†æ›²çº¿ä¸”ç‚¹å¾ˆå°‘ï¼Œå…è®¸å•å‡»æ·»åŠ ï¼ˆè¾…åŠ©èµ·æ­¥ï¼‰
            if (this.currentCurveIndex !== -1 && this.curves[this.currentCurveIndex].points.length < 2) {
                 this.saveState();
                 this.curves[this.currentCurveIndex].points.push(worldMouse);
                 this.draw();
            }
        }
    }

    onMouseMove(e) {
        const mouse = { x: e.offsetX, y: e.offsetY };
        const worldMouse = this.toWorld(mouse.x, mouse.y);
        
        // === 1. ç”»ç¬”ç»˜åˆ¶é€»è¾‘ ===
        if (this.mode === 'draw' && this.isDrawing) {
            const currentCurve = this.curves[this.currentCurveIndex];
            if (!currentCurve) return;
            
            const lastPoint = currentCurve.points[currentCurve.points.length - 1];
            
            const distThreshold = 20 / this.scale; 

            if (Vec2.dist(lastPoint, worldMouse) > distThreshold) {
                currentCurve.points.push(worldMouse);
                this.draw();
            }
            return;
        }

        // === 2. å¹³ç§»é€»è¾‘ ===
        if (this.isPanning) {
            const dx = mouse.x - this.lastMouse.x;
            const dy = mouse.y - this.lastMouse.y;
            this.offsetX += dx;
            this.offsetY += dy;
            this.lastMouse = mouse;
            this.draw();
            return;
        } 
        
        // === 3. æ‹–æ‹½ç‚¹é€»è¾‘ ===
        if (this.isDraggingPoint && this.dragTarget) {
            const c = this.curves[this.dragTarget.curveIndex];
            c.points[this.dragTarget.pointIndex] = worldMouse;
            this.draw();
            return;
        }

        // === 4. æ‚¬åœçŠ¶æ€ (å…‰æ ‡åé¦ˆ) ===
        if (this.mode === 'draw') {
            this.canvas.style.cursor = 'crosshair';
        } else {
            const hitPoint = this.hitTestPoint(worldMouse);
            if (hitPoint) {
                this.canvas.style.cursor = 'move';
            } else {
                const hitCurve = this.hitTestCurve(worldMouse);
                this.canvas.style.cursor = hitCurve !== -1 ? 'pointer' : 'default';
            }
        }
    }

    onMouseUp(e) {
        if (this.mode === 'draw') {
            this.isDrawing = false;
        }
        
        this.isPanning = false;
        this.isDraggingPoint = false;
        this.dragTarget = null;
        
        if (this.mode === 'draw') {
            this.canvas.style.cursor = 'crosshair';
        } else {
            this.canvas.style.cursor = 'default';
        }
    }

    onContextMenu(e) {
        e.preventDefault(); 
        const mouse = { x: e.offsetX, y: e.offsetY };
        const worldMouse = this.toWorld(mouse.x, mouse.y);
        
        const hit = this.hitTestPoint(worldMouse);
        if (hit) {
            this.saveState(); // åˆ é™¤å‰ä¿å­˜
            this.curves[hit.curveIndex].points.splice(hit.pointIndex, 1);
            this.draw();
        }
    }

    onDblClick(e) {
        if (this.mode === 'draw') return; 

        const mouse = { x: e.offsetX, y: e.offsetY };
        const worldMouse = this.toWorld(mouse.x, mouse.y);

        const tension = parseFloat(document.getElementById('tension').value);
        let bestDist = Infinity;
        let insertInfo = null; 

        const threshold = 10 / this.scale;

        this.curves.forEach((curve, cIdx) => {
            if (curve.points.length < 2) return;
            const splinePoints = this.getCardinalSplinePoints(curve.points, tension, 20); 
            
            for (let i = 0; i < splinePoints.length - 1; i++) {
                const p1 = splinePoints[i];
                const d = Vec2.dist(worldMouse, p1);
                
                if (d < threshold && d < bestDist) {
                    bestDist = d;
                    insertInfo = this.findInsertionIndex(cIdx, worldMouse);
                }
            }
        });

        if (insertInfo) {
            this.saveState(); // æ’å…¥å‰ä¿å­˜
            this.curves[insertInfo.curveIndex].points.splice(insertInfo.index, 0, worldMouse);
            this.currentCurveIndex = insertInfo.curveIndex;
            this.draw();
        }
    }

    findInsertionIndex(curveIdx, mousePos) {
        const points = this.curves[curveIdx].points;
        let minD = Infinity;
        let insertIdx = 1;

        for (let i = 0; i < points.length - 1; i++) {
            const pA = points[i];
            const pB = points[i+1];
            const d1 = Vec2.dist(mousePos, pA);
            const d2 = Vec2.dist(mousePos, pB);
            const cost = d1 + d2; 
            if (cost < minD) {
                minD = cost;
                insertIdx = i + 1;
            }
        }
        return { curveIndex: curveIdx, index: insertIdx };
    }

    onWheel(e) {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const mouse = { x: e.offsetX, y: e.offsetY };
        const wheel = e.deltaY < 0 ? 1 : -1;
        const zoom = Math.exp(wheel * zoomIntensity);
        const newScale = this.scale * zoom;
        
        const worldPos = this.toWorld(mouse.x, mouse.y);
        this.offsetX = mouse.x - worldPos.x * newScale;
        this.offsetY = mouse.y - worldPos.y * newScale;
        this.scale = newScale;
        this.draw();
    }

    // --- ç¢°æ’æ£€æµ‹ ---
    hitTestPoint(worldPos) {
        if (this.mode === 'draw') return null;
        const threshold = 12 / this.scale;
        for (let i = 0; i < this.curves.length; i++) {
            const pts = this.curves[i].points;
            for (let j = 0; j < pts.length; j++) {
                if (Vec2.dist(worldPos, pts[j]) < threshold) {
                    return { curveIndex: i, pointIndex: j };
                }
            }
        }
        return null;
    }

    hitTestCurve(worldPos) {
        if (this.mode === 'draw') return -1;
        const threshold = 10 / this.scale;
        const tension = parseFloat(document.getElementById('tension').value);
        
        for (let i = 0; i < this.curves.length; i++) {
            const splinePoints = this.getCardinalSplinePoints(this.curves[i].points, tension, 10);
            for (let p of splinePoints) {
                if (Vec2.dist(worldPos, p) < threshold) return i;
            }
        }
        return -1;
    }

    // --- åŠŸèƒ½å‡½æ•° ---
    addCurve(recordHistory = true) {
        if (recordHistory) this.saveState();
        
        const colors = ['#f09e5e', '#8ac8ef', '#ff0055', '#55ff00', '#aa00ff'];
        if (this.currentCurveIndex !== -1 && this.curves[this.currentCurveIndex].points.length === 0) {
             // å¦‚æœå½“å‰æ˜¯ç©ºæ›²çº¿ï¼Œå°±ä¸æ–°å»ºäº†ï¼Œç›´æ¥ç”¨
        } else {
             const color = colors[this.curves.length % colors.length];
             this.curves.push({ points: [], color: color });
             this.currentCurveIndex = this.curves.length - 1;
        }
        this.draw();
    }
    
    reverseCurve() {
        if (this.currentCurveIndex === -1) return;
        this.saveState();
        this.curves[this.currentCurveIndex].points.reverse();
        this.draw();
    }

    // æ–°å¢ï¼šåˆ é™¤é€‰ä¸­æ›²çº¿
    deleteSelectedCurve() {
        if (this.currentCurveIndex === -1) {
            alert("è¯·å…ˆé€‰ä¸­ä¸€æ¡æ›²çº¿");
            return;
        }
        this.saveState();
        this.curves.splice(this.currentCurveIndex, 1);
        this.currentCurveIndex = -1; // å–æ¶ˆé€‰ä¸­
        // å¦‚æœåˆ å®Œäº†ï¼Œè¡¥ä¸€æ¡ç©ºçš„
        if (this.curves.length === 0) {
            this.addCurve(false);
        }
        this.draw();
    }

    clearAll() {
        if(confirm("ç¡®å®šæ¸…ç©ºï¼Ÿè¿™å°†æ— æ³•æ’¤é”€ï¼ˆéª—ä½ çš„ï¼Œå…¶å®å¯ä»¥æ’¤é”€ï¼‰")) {
            this.saveState();
            this.curves = [];
            this.addCurve(false);
            this.draw();
        }
    }

    handleImage(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const img = new Image();
            img.onload = () => {
                this.bgImage = img;
                this.scale = Math.min((this.canvas.width - 60) / img.width, (this.canvas.height - 60) / img.height);
                this.offsetX = (this.canvas.width - img.width * this.scale) / 2;
                this.offsetY = (this.canvas.height - img.height * this.scale) / 2;
                this.draw();
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    }

    // --- ç»˜åˆ¶æ ¸å¿ƒ ---
    drawArrow(ctx, x, y, angle, size, color, isSelected) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size, size * 0.6);
        ctx.lineTo(-size, -size * 0.6);
        ctx.closePath();
        
        ctx.fillStyle = isSelected ? '#fff' : color;
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = isSelected ? '#000' : '#000'; 
        ctx.stroke();
        
        if (isSelected) {
            ctx.beginPath();
            ctx.arc(0,0, size + 4, 0, Math.PI*2);
            ctx.strokeStyle = '#fff';
            ctx.stroke();
        }
        ctx.restore();
    }

    draw() {
        this.ctx.fillStyle = '#121212';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();

        const origin = this.toScreen(0,0);
        if (this.bgImage) {
            const w = this.bgImage.width * this.scale;
            const h = this.bgImage.height * this.scale;
            this.ctx.drawImage(this.bgImage, origin.x, origin.y, w, h);
            this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            this.ctx.strokeRect(origin.x, origin.y, w, h);
        } else {
            this.ctx.strokeStyle = '#333';
            this.ctx.setLineDash([5, 5]);
            this.ctx.strokeRect(origin.x, origin.y, 400 * this.scale, 400 * this.scale);
            this.ctx.setLineDash([]);
            this.ctx.fillStyle = '#444';
            this.ctx.fillText("åŸç‚¹ (0,0)", origin.x + 5, origin.y + 15);
        }

        const tension = parseFloat(document.getElementById('tension').value);
        
        this.curves.forEach((curve, idx) => {
            const isCurveSelected = idx === this.currentCurveIndex;
            const pts = curve.points;
            
            // 1. ç»˜åˆ¶æ ·æ¡çº¿
            if (pts.length > 1) {
                this.ctx.beginPath();
                // ç»˜åˆ¶æ—¶åªç”¨é€‚ä¸­çš„å¯†åº¦ä»¥æé«˜æ€§èƒ½
                const spline = this.getCardinalSplinePoints(pts, tension, 15);
                const start = this.toScreen(spline[0].x, spline[0].y);
                this.ctx.moveTo(start.x, start.y);
                for(let i=1; i<spline.length; i++) {
                    const p = this.toScreen(spline[i].x, spline[i].y);
                    this.ctx.lineTo(p.x, p.y);
                }
                
                this.ctx.strokeStyle = isCurveSelected ? curve.color : adjustColorOpacity(curve.color, 0.4);
                this.ctx.lineWidth = isCurveSelected ? 3 : 1.5;
                this.ctx.stroke();
            }

            // 2. ç»˜åˆ¶æ§åˆ¶ç‚¹
            if (pts.length > 0) {
                pts.forEach((p, i) => {
                    const screenPos = this.toScreen(p.x, p.y);
                    let angle = 0;
                    
                    if (pts.length > 1) {
                        if (i < pts.length - 1) {
                            angle = Vec2.angle(p, pts[i+1]);
                        } else {
                            angle = Vec2.angle(pts[i-1], p);
                        }
                    }

                    const isPointSelected = isCurveSelected && this.dragTarget && this.dragTarget.pointIndex === i;
                    const size = isCurveSelected ? 8 : 4; 
                    const color = isCurveSelected ? curve.color : '#555';

                    if (!isCurveSelected && pts.length > 50 && i > 0 && i < pts.length -1) {
                        return; 
                    }

                    this.drawArrow(this.ctx, screenPos.x, screenPos.y, angle, size, color, isPointSelected);
                    
                    if (isCurveSelected) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '10px sans-serif';
                        if (i % Math.ceil(pts.length/20) === 0 || i === pts.length-1) {
                            this.ctx.fillText(i, screenPos.x + 10, screenPos.y - 10);
                        }
                    }
                });
            }
        });

        this.ctx.restore();
    }

    // --- æ ¸å¿ƒç®—æ³•ï¼šCardinal Spline ---
    getCardinalSplinePoints(points, tension, segments) {
        if (points.length < 2) return points;
        const res = [];
        const getPt = (i) => points[Math.max(0, Math.min(points.length - 1, i))];

        for (let i = 0; i < points.length - 1; i++) {
            const p0 = getPt(i - 1);
            const p1 = getPt(i);
            const p2 = getPt(i + 1);
            const p3 = getPt(i + 2);

            for (let t = 0; t <= segments; t++) {
                if (t === segments && i < points.length - 2) continue; 
                const t1 = t / segments;
                const t2 = t1 * t1;
                const t3 = t2 * t1;
                const s = (1 - tension) / 2;

                const f1 = 2*t3 - 3*t2 + 1;
                const f2 = -2*t3 + 3*t2;
                const f3 = t3 - 2*t2 + t1;
                const f4 = t3 - t2;

                const x = f1*p1.x + f2*p2.x + f3*(p2.x-p0.x)*s + f4*(p3.x-p1.x)*s;
                const y = f1*p1.y + f2*p2.y + f3*(p2.y-p0.y)*s + f4*(p3.y-p1.y)*s;
                res.push({ x: x, y: y });
            }
        }
        return res;
    }

    // --- æ–°å¢ï¼šæŒ‰æ€»é•¿åº¦å‡åŒ€é‡é‡‡æ ·è·¯å¾„ ---
    resamplePolyline(points, targetCount) {
        if (points.length === 0) return [];
        if (targetCount < 2) return [points[0]];

        // 1. è®¡ç®—æ€»é•¿åº¦å’Œå„æ®µé•¿åº¦
        let totalLen = 0;
        const dists = [0];
        for (let i = 0; i < points.length - 1; i++) {
            const d = Vec2.dist(points[i], points[i+1]);
            totalLen += d;
            dists.push(totalLen);
        }

        const resampled = [];
        const step = totalLen / (targetCount - 1);

        // 2. å‡åŒ€æ’å€¼
        let currentDist = 0;
        for (let i = 0; i < targetCount; i++) {
            if (i === targetCount - 1) {
                resampled.push(points[points.length - 1]);
                break;
            }

            let idx = 0;
            while (idx < dists.length - 1 && dists[idx+1] < currentDist) {
                idx++;
            }

            const start = points[idx];
            const end = points[idx+1];
            const segStartDist = dists[idx];
            const segLen = dists[idx+1] - dists[idx];
            
            let t = 0;
            if (segLen > 0.0001) {
                t = (currentDist - segStartDist) / segLen;
            }

            const x = start.x + (end.x - start.x) * t;
            const y = start.y + (end.y - start.y) * t;
            resampled.push({x, y});

            currentDist += step;
        }
        return resampled;
    }

    exportJson() {
        const tension = parseFloat(document.getElementById('tension').value);
        const totalFrames = parseInt(document.getElementById('totalFramesInput').value) || 81;
        
        const exportData = this.curves
            .filter(c => c.points.length > 1)
            .map(c => {
                const highResPoints = this.getCardinalSplinePoints(c.points, tension, 50);
                const finalPoints = this.resamplePolyline(highResPoints, totalFrames);

                return finalPoints.map(p => ({
                    x: Math.round(p.x),
                    y: Math.round(p.y)
                }));
            });

        const jsonStr = JSON.stringify(exportData);
        const output = document.getElementById('output');
        output.value = jsonStr;
        output.select();
        document.execCommand("copy");
        
        const btn = document.querySelector('button.primary');
        const oldText = btn.innerText;
        btn.innerText = "å·²å¤åˆ¶ï¼";
        setTimeout(() => btn.innerText = oldText, 1000);
    }
}

function adjustColorOpacity(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

const editor = new SplineEditor();

</script>
</body>
</html>